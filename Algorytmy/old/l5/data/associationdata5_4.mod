param n, integer, >= 1; #

set V, default {0..n-1}; #

set E, within V cross V;

param capacity{(i,j) in E}, >= 0;

param source, symbolic, in V, default 0;

param sink, symbolic, in V, != source, default n-1;

var flow{(i,j) in E}, >= 0, <= capacity[i,j];

var maxFlow, >= 0;

s.t. condition_1{i in V: i<>source and i<>sink}:
   sum{(j,i) in E} flow[j,i] = sum{(i,j) in E} flow[i,j];
   
s.t. condition_2{i in V: i=source}:
   maxFlow = sum{(i,j) in E} flow[i,j];
   
s.t. condition_3{i in V: i=sink}:
   maxFlow = sum{(j,i) in E} flow[j,i] ;

maximize obj: maxFlow;

solve;

printf "Maximum flow: %s\n", maxFlow;

data;
param n := 66;
param : E :   capacity :=
0 1 1
0 2 1
0 3 1
0 4 1
0 5 1
0 6 1
0 7 1
0 8 1
0 9 1
0 10 1
0 11 1
0 12 1
0 13 1
0 14 1
0 15 1
0 16 1
0 17 1
0 18 1
0 19 1
0 20 1
0 21 1
0 22 1
0 23 1
0 24 1
0 25 1
0 26 1
0 27 1
0 28 1
0 29 1
0 30 1
0 31 1
0 32 1
1 45 1
1 58 1
1 55 1
1 59 1
2 36 1
2 60 1
2 48 1
2 45 1
3 62 1
3 47 1
3 41 1
3 63 1
4 46 1
4 36 1
4 42 1
4 54 1
5 40 1
5 60 1
5 50 1
5 52 1
6 36 1
6 53 1
6 46 1
6 44 1
7 64 1
7 53 1
7 59 1
7 35 1
8 39 1
8 61 1
8 64 1
8 42 1
9 47 1
9 53 1
9 57 1
9 43 1
10 40 1
10 60 1
10 49 1
10 33 1
11 33 1
11 58 1
11 60 1
11 40 1
12 59 1
12 51 1
12 46 1
12 37 1
13 57 1
13 38 1
13 54 1
13 58 1
14 37 1
14 59 1
14 52 1
14 33 1
15 51 1
15 38 1
15 47 1
15 50 1
16 53 1
16 55 1
16 33 1
16 56 1
17 42 1
17 46 1
17 41 1
17 51 1
18 60 1
18 56 1
18 33 1
18 39 1
19 53 1
19 61 1
19 55 1
19 44 1
20 57 1
20 45 1
20 55 1
20 47 1
21 45 1
21 38 1
21 37 1
21 47 1
22 36 1
22 48 1
22 42 1
22 45 1
23 64 1
23 53 1
23 37 1
23 43 1
24 49 1
24 58 1
24 47 1
24 45 1
25 57 1
25 35 1
25 61 1
25 44 1
26 47 1
26 54 1
26 43 1
26 57 1
27 49 1
27 33 1
27 40 1
27 39 1
28 41 1
28 48 1
28 57 1
28 53 1
29 49 1
29 40 1
29 60 1
29 42 1
30 47 1
30 61 1
30 34 1
30 52 1
31 55 1
31 33 1
31 46 1
31 35 1
32 55 1
32 60 1
32 59 1
32 36 1
33 65 1
34 65 1
35 65 1
36 65 1
37 65 1
38 65 1
39 65 1
40 65 1
41 65 1
42 65 1
43 65 1
44 65 1
45 65 1
46 65 1
47 65 1
48 65 1
49 65 1
50 65 1
51 65 1
52 65 1
53 65 1
54 65 1
55 65 1
56 65 1
57 65 1
58 65 1
59 65 1
60 65 1
61 65 1
62 65 1
63 65 1
64 65 1
;
end;
