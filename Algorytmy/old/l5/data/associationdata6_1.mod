param n, integer, >= 1; #

set V, default {0..n-1}; #

set E, within V cross V;

param capacity{(i,j) in E}, >= 0;

param source, symbolic, in V, default 0;

param sink, symbolic, in V, != source, default n-1;

var flow{(i,j) in E}, >= 0, <= capacity[i,j];

var maxFlow, >= 0;

s.t. condition_1{i in V: i<>source and i<>sink}:
   sum{(j,i) in E} flow[j,i] = sum{(i,j) in E} flow[i,j];
   
s.t. condition_2{i in V: i=source}:
   maxFlow = sum{(i,j) in E} flow[i,j];
   
s.t. condition_3{i in V: i=sink}:
   maxFlow = sum{(j,i) in E} flow[j,i] ;

maximize obj: maxFlow;

solve;

printf "Maximum flow: %s\n", maxFlow;

data;
param n := 130;
param : E :   capacity :=
0 1 1
0 2 1
0 3 1
0 4 1
0 5 1
0 6 1
0 7 1
0 8 1
0 9 1
0 10 1
0 11 1
0 12 1
0 13 1
0 14 1
0 15 1
0 16 1
0 17 1
0 18 1
0 19 1
0 20 1
0 21 1
0 22 1
0 23 1
0 24 1
0 25 1
0 26 1
0 27 1
0 28 1
0 29 1
0 30 1
0 31 1
0 32 1
0 33 1
0 34 1
0 35 1
0 36 1
0 37 1
0 38 1
0 39 1
0 40 1
0 41 1
0 42 1
0 43 1
0 44 1
0 45 1
0 46 1
0 47 1
0 48 1
0 49 1
0 50 1
0 51 1
0 52 1
0 53 1
0 54 1
0 55 1
0 56 1
0 57 1
0 58 1
0 59 1
0 60 1
0 61 1
0 62 1
0 63 1
0 64 1
1 112 1
2 128 1
3 67 1
4 108 1
5 98 1
6 126 1
7 105 1
8 122 1
9 77 1
10 119 1
11 106 1
12 121 1
13 125 1
14 122 1
15 82 1
16 86 1
17 95 1
18 79 1
19 76 1
20 112 1
21 126 1
22 113 1
23 110 1
24 109 1
25 120 1
26 121 1
27 83 1
28 110 1
29 120 1
30 79 1
31 78 1
32 124 1
33 108 1
34 112 1
35 72 1
36 85 1
37 109 1
38 86 1
39 125 1
40 121 1
41 80 1
42 77 1
43 84 1
44 75 1
45 66 1
46 101 1
47 67 1
48 99 1
49 83 1
50 119 1
51 87 1
52 69 1
53 104 1
54 83 1
55 78 1
56 66 1
57 101 1
58 101 1
59 115 1
60 74 1
61 108 1
62 81 1
63 68 1
64 66 1
65 129 1
66 129 1
67 129 1
68 129 1
69 129 1
70 129 1
71 129 1
72 129 1
73 129 1
74 129 1
75 129 1
76 129 1
77 129 1
78 129 1
79 129 1
80 129 1
81 129 1
82 129 1
83 129 1
84 129 1
85 129 1
86 129 1
87 129 1
88 129 1
89 129 1
90 129 1
91 129 1
92 129 1
93 129 1
94 129 1
95 129 1
96 129 1
97 129 1
98 129 1
99 129 1
100 129 1
101 129 1
102 129 1
103 129 1
104 129 1
105 129 1
106 129 1
107 129 1
108 129 1
109 129 1
110 129 1
111 129 1
112 129 1
113 129 1
114 129 1
115 129 1
116 129 1
117 129 1
118 129 1
119 129 1
120 129 1
121 129 1
122 129 1
123 129 1
124 129 1
125 129 1
126 129 1
127 129 1
128 129 1
;
end;
